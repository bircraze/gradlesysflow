project.ext {
    sysTplPrefix = "tpl"
    sysEnvPrefix = "flow"
    sysEnvDiv = "_"
    commomAction = {
        def index = 0
        project.ext.envMap["steps"].keySet().eachWithIndex { ele, i ->
            if (ele == name) {
                index = i
            }
        }
        def forGroovyBugMap = project.ext.envMap["steps"].values().toArray()[index]
        if (!forGroovyBugMap["rootonly"]) {
            preExecChild(forGroovyBugMap, projectDir)
            return
        }
        println "=================================="
        println "Exec root task: ${name}"
        println "=================================="
        if (forGroovyBugMap["cmd"]) {
            def cmd = forGroovyBugMap["cmd"]
            def args = []
            args << forGroovyBugMap["subcmd"] << forGroovyBugMap["args"]
            execCmd(cmd, args.flatten() - "" - null, projectDir)
        }
    }

    genEnvTasks()
}

subprojects {
    task execRootCmd {
        doLast {
            def argsArr = project.ext.args.split(",")
            def newArgsArr = []
            newArgsArr << project.ext.subcmd
            newArgsArr << argsArr.collect([]) {
                (it.split(":::")[0] && it.split(":::")[1] == project.name) ? it.split(":::")[0] : ""
            }
            execCmd(project.ext.cmd, newArgsArr.flatten() - "" - null, projectDir)
        }
    }
}

def genArgs(stepTaskMap, subs) {
    def argsArr = stepTaskMap["args"]
    def newArgsArr = []
    argsArr.each { arg ->
        if (arg.contains(":::")) {
            def pName = arg.split(":::")[1]
            stepTaskMap[pName].each { p ->
                def newArg = arg.replace(":::${pName}:::", p.key)
                p.value.each { sub ->
                    newArgsArr << "${newArg}:::${sub}"
                }
            }
        } else {
            subs.each { sub ->
                newArgsArr << "${arg}:::${sub}"
            }
        }
    }
    def result = newArgsArr ? newArgsArr.join(",") : ""

    return result
}

def genSubs(stepTaskMap) {
    def argsArr = stepTaskMap["args"]
    argsArr = argsArr.findAll {
        it.contains(":::")
    }
    if (!argsArr) {
        return project.ext.envMap["parties"].join(",")
    }

    def newParties = []
    argsArr.each {
        def pName = it.split(":::")[1]
        newParties << stepTaskMap[pName].values()
    }
    def result = newParties ? newParties.flatten().unique().join(",") : ""

    return result
}

def execCmd(cmd, argus, wdir) {
    println "===================================="
    println "Run cmd: ${cmd}, args: ${argus}, destDir: ${wdir}"
    project.exec {
        commandLine cmd
        //commandLine "git", "fetch"
        args argus
        //args "origin"
        workingDir wdir
    }
    println "===================================="
}

def preExecChild(stepTaskMap, wdir) {
    def argsArr = []
    def envCmd = stepTaskMap["cmd"]
    def envSubCmd = stepTaskMap["subcmd"]
    def subs = genSubs(stepTaskMap)
    argsArr << subs.split(",").collect { ":${it}:execRootCmd" }
    argsArr << "-Pcmd=${envCmd}"
    argsArr << "-Psubcmd=${envSubCmd}"
    argsArr << "-Pargs=${genArgs(stepTaskMap, subs.split(','))}"
    argsArr << "--configure-on-demand"

    if (stepTaskMap["parallel"]) {
        execCmd("gradle", (argsArr << "--parallel").flatten(), wdir)
    } else {
        execCmd("gradle", argsArr.flatten(), wdir)
    }
}

def genEnvTasks() {
    project.ext.properties.keySet().findAll { it.startsWith(project.ext.sysTplPrefix) }.each { i -> 
        project.ext.properties.keySet().findAll { it.startsWith(project.ext.sysEnvPrefix) }.each { j ->
            if (j ==~ project.ext."${i}"["applyfor"]) {
                def taskName = project.ext."${i}"["alias"] + j.split(project.ext.sysEnvDiv)[1]
                task "${taskName}" {
                    doLast {
                        "${j}"()
                        project.ext.envMap = project.ext.deepcopy(project.ext."${i}")
                        genMainTask(project.ext.envMap)
                    }
                }
                tasks."${taskName}".group "[0] Flow"
                tasks."${taskName}".description "Execute: " + project.ext."${i}"['steps'].keySet()
            }
        }
    }
}

def overRideEnvArgs(stepTaskMap) {
    def argsArr = stepTaskMap["args"]
    argsArr.each { arg ->
        if (arg.contains(":::")) {
            def pName = arg.split(":::")[1]
            if (project.hasProperty(pName)) {
                stepTaskMap << project.ext."${pName}"
            }
        }
    }
}

def genMainTask(taskMap) {
    taskMap["steps"].keySet().each {
        overRideEnvArgs(taskMap["steps"][it])
        task "${it}"
        tasks."${it}".doLast(project.ext.commomAction)
        if (project.ext.prop("${it}ExAction")) {
            tasks."${it}".doLast(project.ext."${it}ExAction")
        }
        tasks."${it}".execute()
    }
}
