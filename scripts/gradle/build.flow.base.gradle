project.ext {
    execCmdLine = { cmd, argus, wdir ->
        println "===================================="
        println "Run cmd: ${cmd}, args: ${argus}, destDir: ${wdir}"
        project.exec {
            commandLine cmd
            //commandLine "git", "fetch"
            args argus
            //args "origin"
            workingDir wdir
        }
        println "===================================="
    }
    preExecChild = { stepTaskMap, wdir ->
        def argsArr = []
        def flowCmd = stepTaskMap["cmd"]
        def flowSubCmd = stepTaskMap["subcmd"]
        def subs = genSubs(stepTaskMap)
        argsArr << subs.split(",").collect { ":${it}:execChildCmdLine" }
        argsArr << "-Pcmd=${flowCmd}"
        argsArr << "-Psubcmd=${flowSubCmd}"
        argsArr << "-Pargs=${genArgs(stepTaskMap, subs.split(','))}"
        if (project.hasProperty("subPrjRoot")) {
            argsArr << "-PsubPrjRoot=${project.ext.subPrjRoot}"
        }
        argsArr << "-PsubPrjs=${subs}"
        argsArr << "--configure-on-demand"

        if (stepTaskMap["parallel"]) {
            execCmdLine("gradle", (argsArr << "--parallel").flatten(), wdir)
        } else {
            execCmdLine("gradle", argsArr.flatten(), wdir)
        }
    }
    commomAction = {
        def index = 0
        project.ext.flowMap["steps"].keySet().eachWithIndex { ele, i ->
            if (ele == name) {
                index = i
            }
        }
        def forGroovyBugMap = project.ext.flowMap["steps"].values().toArray()[index]
        if (!forGroovyBugMap["rootonly"]) {
            preExecChild(forGroovyBugMap, projectDir)
            return
        }
        println "=================================="
        println "Exec root task: ${name}"
        println "=================================="
        if (forGroovyBugMap["cmd"]) {
            def cmd = forGroovyBugMap["cmd"]
            def args = []
            args << forGroovyBugMap["subcmd"] << forGroovyBugMap["args"]
            execCmdLine(cmd, args.flatten() - "" - null, projectDir)
        }
    }
}

subprojects {
    task execChildCmdLine {
        doLast {
            def argsArr = project.ext.args.split(",")
            def newArgsArr = []
            newArgsArr << project.ext.subcmd
            newArgsArr << argsArr.collect([]) {
                (it.split(":::")[0] && it.split(":::")[1] == project.name) ? it.split(":::")[0] : ""
            }
            execCmdLine(project.ext.cmd, newArgsArr.flatten() - "" - null, projectDir)
        }
    }
}

task genFlow {
    genFlowTasks()
}

def genArgs(stepTaskMap, subs) {
    def argsArr = stepTaskMap["args"]
    def newArgsArr = []
    argsArr.each { arg ->
        if (arg.contains(":::")) {
            def pName = arg.split(":::")[1]
            stepTaskMap[pName].each { p ->
                def newArg = arg.replace(":::${pName}:::", p.key)
                p.value.each { sub ->
                    newArgsArr << "${newArg}:::${sub}"
                }
            }
        } else {
            subs.each { sub ->
                newArgsArr << "${arg}:::${sub}"
            }
        }
    }
    def result = newArgsArr ? newArgsArr.join(",") : ""

    return result
}

def genSubs(stepTaskMap) {
    if (stepTaskMap["subprjs"]) {
        return stepTaskMap["subprjs"].join(",")
    }
    def argsArr = stepTaskMap["args"]
    argsArr = argsArr.findAll {
        it.contains(":::")
    }
    if (!argsArr) {
        return defaultSubPrjStr()
    }

    def newParties = []
    argsArr.each {
        def pName = it.split(":::")[1]
        newParties << stepTaskMap[pName].values()
    }
    def result = newParties ? newParties.flatten().unique().join(",") : ""

    return result
}

def genFlowTasks() {
    project.ext.properties.keySet().findAll { it.startsWith(project.ext.sysTplPrefix + project.ext.sysFlowDiv) }.each { i -> 
        project.ext.properties.keySet().findAll { it.startsWith(project.ext.sysFlowPrefix + project.ext.sysFlowDiv) }.each { j ->
            if (j ==~ project.ext."${i}"["applyfor"]) {
                def taskName = project.ext."${i}"["alias"] + j.split(project.ext.sysFlowDiv)[1]
                task "${taskName}" {
                    doLast {
                        "${j}"()
                        project.ext.flowMap = project.ext.deepcopy(project.ext."${i}")
                        genStepTasks(project.ext.flowMap)
                    }
                }
                tasks."${taskName}".group "[0] Flow"
                tasks."${taskName}".description "Execute: " + project.ext."${i}"['steps'].keySet()
            }
        }
    }
}

def overrideFlowArgs(stepTaskMap) {
    def argsArr = stepTaskMap["args"]
    argsArr.each { arg ->
        if (arg.contains(":::")) {
            def pName = arg.split(":::")[1]
            if (project.hasProperty(pName)) {
                stepTaskMap << project.ext."${pName}"
            }
        }
    }
}

def genStepTasks(taskMap) {
    taskMap["steps"].keySet().eachWithIndex { it, i ->
        overrideFlowArgs(taskMap["steps"].values().toArray()[i])
        task "${it}"
        tasks."${it}".doLast(project.ext.commomAction)
        if (project.ext.prop("${it}ExAction")) {
            tasks."${it}".doLast(project.ext."${it}ExAction")
        }
        tasks."${it}".execute()
    }
}
