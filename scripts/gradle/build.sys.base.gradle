project.ext {
    sysEnvPrefix = "env"
    sysEnvDiv = "_"
    usingParallel = gradle.startParameter.isParallelProjectExecutionEnabled()
    commomAction = {
        def index = 0
        project.ext.envMap["steps"].keySet().eachWithIndex { ele, i ->
            if (ele == name) {
                index = i
            }
        }
        def forGroovyBugMap = project.ext.envMap["steps"].values().toArray()[index]
        if (!forGroovyBugMap["rootonly"]) {
            preExecChild(forGroovyBugMap, projectDir)
            return
        }
        println "=================================="
        println "Exec root task: ${name}"
        println "=================================="
        if (forGroovyBugMap["cmd"]) {
            def cmd = forGroovyBugMap["cmd"]
            def args = []
            args << forGroovyBugMap["subcmd"] << forGroovyBugMap["args"]
            execCmd(cmd, args.flatten() - "" - null, projectDir)
        }
    }

    genEnvTasks()
}

subprojects {
    task execRootCmd {
        doLast {
            def argsArr = project.ext.args.split(",")
            def newArgsArr = []
            newArgsArr << project.ext.subcmd
            newArgsArr << argsArr.collect([]) {
                (it.split(":::")[0] && it.split(":::")[1] == project.name) ? it.split(":::")[0] : ""
            }
            execCmd(project.ext.cmd, newArgsArr.flatten() - "" - null, projectDir)
        }
    }
}

def genArgs(stepTaskMap, subs) {
    def argsArr = stepTaskMap["args"]
    def newArgsArr = []
    argsArr.each { arg ->
        if (arg.contains(":::")) {
            def pName = arg.split(":::")[1]
            stepTaskMap[pName].each { p ->
                def newArg = arg.replace(":::${pName}:::", p.key)
                p.value.each { sub ->
                    newArgsArr << "${newArg}:::${sub}"
                }
            }
        } else {
            subs.each { sub ->
                newArgsArr << "${arg}:::${sub}"
            }
        }
    }
    def result = newArgsArr ? newArgsArr.join(",") : ""

    return result
}

def genSubs(stepTaskMap) {
    def argsArr = stepTaskMap["args"]
    argsArr = argsArr.findAll {
        it.contains(":::")
    }
    if (!argsArr) {
        return project.ext.envMap["parties"].join(",")
    }

    def newParties = []
    argsArr.each {
        def pName = it.split(":::")[1]
        newParties << stepTaskMap[pName].values()
    }
    def result = newParties ? newParties.flatten().unique().join(",") : ""

    return result
}

def execCmd(cmd, argus, wdir) {
    println "===================================="
    println "Run cmd: ${cmd}, args: ${argus}, destDir: ${wdir}"
    project.exec {
        commandLine cmd
        //commandLine "git", "fetch"
        args argus
        //args "origin"
        workingDir wdir
    }
    println "===================================="
}

def preExecChild(stepTaskMap, wdir) {
    def argsArr = []
    def envCmd = stepTaskMap["cmd"]
    def envSubCmd = stepTaskMap["subcmd"]
    def subs = genSubs(stepTaskMap)
    argsArr << subs.split(",").collect { ":${it}:execRootCmd" }
    argsArr << "-Pcmd=${envCmd}"
    argsArr << "-Psubcmd=${envSubCmd}"
    argsArr << "-Pargs=${genArgs(stepTaskMap, subs.split(','))}"
    argsArr << "--configure-on-demand"

    if (usingParallel && stepTaskMap["parallel"] != null && stepTaskMap["parallel"]) {
        execCmd("gradle", (argsArr << "--parallel").flatten(), wdir)
    } else {
        execCmd("gradle", argsArr.flatten(), wdir)
    }
}

def genEnvTasks() {
    for (each in project.ext.properties.keySet()) {
        if (each.startsWith(project.ext.sysEnvPrefix)) {
            genMainTask(each.split(project.ext.sysEnvDiv)[1], project.ext.properties.get(each))
        }
    }
}

def genMainTask(taskName, taskMap) {
    task "${taskName}" {
        doLast {
            project.ext.envMap = taskMap.clone()
            taskMap["steps"].keySet().each {
                task "${it}"
                tasks."${it}".doLast(project.ext.commomAction)
                if (project.ext.prop("${it}ExAction")) {
                    tasks."${it}".doLast(project.ext."${it}ExAction")
                }
                tasks."${it}".execute()
            }
        }
    }
    tasks."${taskName}".group "Environment"
    tasks."${taskName}".description "Execute: ${taskMap['steps'].keySet()}"
}
